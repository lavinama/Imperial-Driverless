'''
This node listens to a topic and periodically captures a tuple of 
    (image, 
    {
    'yellow'        : [pos1, pos2, ... posN],
    'blue'          : [pos1, pos2, ... posN],
    'big_orange'    : [pos1, pos2, ... posN],
    'small_orange'  : [pos1, pos2, ... posN],
    } )

image and ground truths.

Image saver code from https://gist.github.com/rethink-imcmahon/77a1a4d5506258f3dc1f

Read on how to use this file in the Readme.
'''

from ament_index_python import get_package_share_directory
import os
import rclpy
import rclpy.node
import fs_msgs.msg

from nav_msgs.msg import Odometry
from geometry_msgs.msg import Pose
from sensor_msgs.msg import Image
from std_msgs.msg import Bool

import numpy as np
import tf_transformations as tr

from cv_bridge import CvBridge, CvBridgeError
import cv2
import csv
from datetime import datetime

# Instanstiate the bridge
bridge = CvBridge()

class FSTrackToConemap(rclpy.node.Node):
    def __init__(self):
        super().__init__('fs_track_to_conemap')
        
        command_topic = '/take_picture'
        cam1_topic = '/fsds/cam1'
        cam2_topic = '/fsds/cam2'
        fs_track_topic = '/testing_only/track'
        odom_topic = '/testing_only/odom'

        # new folder each time there is a new run
        self.save_source = os.path.expanduser(f"~/Formula-Student-Driverless-Simulator/test_data/{datetime.now().strftime('%d_%m_%Y_%H_%M_%S')}")
        self.get_logger().info(f"Saving dataset in {self.save_source}")
        if not os.path.exists(self.save_source):
            self.get_logger().info(f"Save folder does not exist, creating it.")
            os.makedirs(self.save_source)

        self._cmd_sub = self.create_subscription(Bool, command_topic, self._cmd_callback, 10)
        self._fs_track_sub = self.create_subscription(fs_msgs.msg.Track, fs_track_topic, self._fs_track_callback, 10)
        self._odom_sub = self.create_subscription(Odometry, odom_topic, self._odom_callback, 10)
        self._cam1_sub = self.create_subscription(Image, cam1_topic, self._cam1_callback, 10)
        self._cam2_sub = self.create_subscription(Image, cam2_topic, self._cam2_callback, 10)

        # taken from settings.json
        self.cam_fov = np.radians(90)   # in radians
        self.cam1_g = np.array((
            (1,0,0,-0.3),
            (0,1,0,-0.16),
            (0,0,1,0.8),
            (0,0,0,1)
        ))
        self.cam2_g = np.array((
            (1,0,0,-0.3),
            (0,1,0, 0.16),
            (0,0,1,0.8),
            (0,0,0,1)
        ))

        self.cones = []

        self._img_ctr = 1

    def _cmd_callback(self, msg: Bool):
        '''
        Takes a picture and returns cones seen by Cam1 and Cam2

        These messages can be saved to disk or something?
        '''
        self.get_logger().info(f"Taking picture {self._img_ctr}.")

        # --- Cam1 ---
        self.get_logger().info("Cam 1 processing")
        self.get_relevant_cones(1, self.cam_fov)
        

        # Do the same for Cam2
        # --- Cam2 ---
        self.get_logger().info("Cam 2 processing")
        self.get_relevant_cones(2, self.cam_fov)

        self._img_ctr += 1

    def _fs_track_callback(self, msg: fs_msgs.msg.Track):
        # Store Track into an array of Cone objects
        self.cones = msg.track
        self.get_logger().info(f"Got cone map with length {len(self.cones)}")

    def _odom_callback(self, msg: Odometry):
        self._pose = msg.pose.pose

    def _cam1_callback(self, msg: Image):
        self._cam1_image = msg
        self.get_logger().debug( f"Camera 1 img data: Header[{msg.header.frame_id}, {msg.header.stamp}]\n" + \
                                f"H: {msg.height}, W: {msg.width} E: {msg.encoding} | {msg.is_bigendian} | {msg.step}"
        )

    def _cam2_callback(self, msg: Image):
        self._cam2_image = msg
        self.get_logger().debug( f"Camera 2 img data: Header[{msg.header.frame_id}, {msg.header.stamp}]\n" + \
                                f"H: {msg.height}, W: {msg.width} E: {msg.encoding} | {msg.is_bigendian} | {msg.step}"
        )
    
    @staticmethod
    def transform_matrix_from_pose(pose: Pose):
        # Get p,q into a SE(3) 4x4 transformation matrix
        # src: https://answers.ros.org/question/332407/transformstamped-to-transformation-matrix-python/

        p = np.array([pose.position.x, pose.position.y, pose.position.z])
        q = np.array([pose.orientation.x, pose.orientation.y,
                  pose.orientation.z, pose.orientation.w])

        # g is the transformation matrix
        g = tr.quaternion_matrix(q)
        g[0:3, -1] = p

        return g

    def get_relevant_cones(self, cam:int, cam_fov_rad:float):
        '''
        Filters list of cones based on its location in the field of view.

        Args:
        - cam (int): either 1 or 2 (left or right cam)
        - cam_fov_rad: corresponding to the field of view of the camera (in radians)
        '''

        self.get_logger().info(f"Cam{cam} processing")
        cam_line_grad = np.sin(cam_fov_rad/2)
        
        # Specific transform matrices, images
        if cam==1:
            img = self._cam1_image
            cam_g = self.cam1_g
        elif cam==2:
            img = self._cam2_image
            cam_g = self.cam2_g
        else:
            self.get_logger().warn(f"Got Cam{cam} as input. Put either 1 or 2")

        # output: --> pair of files:
        # {FILENAME}.image -> test image
        # {FILENAME}.csv   -> CSV of (class, x, y)

        cam_resp = {
            'yellow'        : [],
            'blue'          : [],
            'big_orange'    : [],
            'small_orange'  : [],
        }

        # Get transformation from World frame to Cam1 frame
        # World -> Car is in the Odom topic (self._position, self._orientation)
        g = self.transform_matrix_from_pose(self._pose)
        g = cam_g @ g
        # self.get_logger().info(f"Car transform matrix:\n{g}")

        # Iterate over all cones
        if len(self.cones) == 0:
            self.get_logger().warn("Cone list is empty.")

        for cone in self.cones:
            # Transform cone coordinate to car coordinate
            g_inv = np.linalg.inv(g)
            g_cone = np.array(
                ((1, 0, 0, cone.location.x),
                (0, 1, 0, cone.location.y),
                (0, 0, 1, cone.location.z),
                (0, 0, 0, 1))
            )
            g_cone_car = g_inv @ g_cone
            # self.get_logger().info(f"Cone transform matrix:\n{g}")

            cone_x_car = g_cone_car[0, -1]
            cone_y_car = g_cone_car[1, -1]

            # Filter based on camera FOV
            if cone_x_car*cam_line_grad > cone_y_car \
            and -cone_x_car*cam_line_grad < cone_y_car:
                # it is within the camera's field of view, add this to the dict that should be returned
                if   cone.color==fs_msgs.msg.Cone.BLUE:
                    cam_resp['blue'].append((cone_x_car, cone_y_car))
                elif cone.color==fs_msgs.msg.Cone.YELLOW:
                    cam_resp['yellow'].append((cone_x_car, cone_y_car))
                elif cone.color==fs_msgs.msg.Cone.ORANGE_BIG:
                    cam_resp['big_orange'].append((cone_x_car, cone_y_car))
                elif cone.color==fs_msgs.msg.Cone.ORANGE_SMALL:
                    cam_resp['small_orange'].append((cone_x_car, cone_y_car))
                
                self.get_logger().debug(f"Cam{cam} found {cone.color} cone at {cone_x_car:.2f}, {cone_y_car:.2f} (global {cone.location.x:.2f}, {cone.location.y:.2f})")
        
        try:
            cam_img = bridge.imgmsg_to_cv2(img, 'bgr8')
        except CvBridgeError as e:
            self.get_logger().warn(f"{e}")
        else:
            # Save as image and dump data
            filepath = os.path.join(self.save_source, f'{self._img_ctr}_cam{cam}')
            self.get_logger().info(f"Writing image to {filepath}")
            cv2.imwrite(filepath+'.png', cam_img, [cv2.IMWRITE_PNG_COMPRESSION, 0])
            
            # Write data as CSV
            with open(filepath+'.csv', 'w') as f:
                writer = csv.writer(f)
                writer.writerow(['class', 'x', 'y'])
                for (x,y) in cam_resp['blue']:
                    writer.writerow(['blue', x, y])
                for (x,y) in cam_resp['yellow']:
                    writer.writerow(['yellow', x, y])
                for (x,y) in cam_resp['big_orange']:
                    writer.writerow(['big_orange', x, y])
                for (x,y) in cam_resp['small_orange']:
                    writer.writerow(['small_orange', x, y])

def main():
    rclpy.init()
    node = FSTrackToConemap()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()
