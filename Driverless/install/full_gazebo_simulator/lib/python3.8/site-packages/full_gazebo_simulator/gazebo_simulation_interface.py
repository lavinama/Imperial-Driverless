import rclpy
import rclpy.node
from rclpy.qos import QoSProfile, QoSDurabilityPolicy

import std_srvs.srv
import std_msgs.msg

import xacro
import xml.dom.minidom

import math
import sys
from urllib.parse import SplitResult, urlsplit
from lxml import etree as ElementTree

from gazebo_msgs.srv import SpawnEntity
from geometry_msgs.msg import Pose
import rclpy
from rclpy.qos import QoSDurabilityPolicy
from rclpy.qos import QoSProfile

latching_qos = QoSProfile(depth=1, durability=QoSDurabilityPolicy.TRANSIENT_LOCAL)

class GazeboSimulationInterface(rclpy.node.Node):
    def __init__(self):
        super().__init__("gazebo_simulation_reset_interface")
        self.declare_parameter('urdf_include', '')
        self.declare_parameter('vehicle_config_path', '')

        self.declare_parameter('x',  0.0)
        self.declare_parameter('y',  0.0)
        self.declare_parameter('th', 0.0)
        self.package_to_model = False
        

        self.vehicle_config_path = self.get_parameter('vehicle_config_path').value
        if not self.vehicle_config_path:
            raise ValueError('vehicle_config_path parameter must be set')

        self.initial_pose = self.compute_initial_pose()

        self.urdf_sub = self.create_subscription(
            std_msgs.msg.String,
            '/robot_description',
            self.amend_urdf_and_spawn,
            latching_qos)

        self.srv = self.create_service(
            std_srvs.srv.Empty,
            "/id_reset_simulation",
            self.reset_simulation
        )

        self.spawn_entity_client = self.create_client(SpawnEntity, '/spawn_entity')
        self.gazebo_reset_client = self.create_client(std_srvs.srv.Empty, '/reset_simulation')

        self.final_entity_xml = None

    def compute_initial_pose(self) -> Pose:
        # Form requested Pose from arguments
        initial_pose = Pose()
        initial_pose.position.x = float(self.get_parameter('x').value)
        initial_pose.position.y = float(self.get_parameter('y').value)
        initial_pose.position.z = float(0.0)

        q = quaternion_from_euler(0.0, 0.0, float(self.get_parameter('th').value))
        initial_pose.orientation.w = q[0]
        initial_pose.orientation.x = q[1]
        initial_pose.orientation.y = q[2]
        initial_pose.orientation.z = q[3]

        return initial_pose

    def _spawn_entity(self, timeout=30.0):
        if self.final_entity_xml is None:
            raise ValueError('final_entity_xml is None')

        if timeout < 0:
            self.get_logger().error('spawn_entity timeout must be greater than zero')
            return False
        self.get_logger().info(f'Waiting for service /spawn_entity, timeout = {timeout}')
        
        if self.spawn_entity_client.wait_for_service(timeout_sec=timeout):
            req = SpawnEntity.Request()
            req.name = 'racecar'
            req.xml = self.final_entity_xml
            # req.robot_namespace unspecified
            req.initial_pose = self.initial_pose
            # req.reference_frame unspecified, so default world frame used
            self.get_logger().info('Calling service /spawn_entity')

            assert self.executor
            self.spawn_entity_client.call_async(req)

        self.get_logger().error(
            'Service /spawn_entity unavailable. Was Gazebo started with GazeboRosFactory?')
        return False

    def amend_urdf(self, urdf: str) -> str:
        urdf_include = self.get_parameter('urdf_include').value
        
        doc: xml.dom.minidom.Document = xacro.parse(urdf) # type: ignore
        
        robot_tag: xml.dom.minidom.Element = doc.getElementsByTagName('robot')[0]

        if urdf_include:
            e: xml.dom.minidom.Element = doc.createElement('xacro:include')
            e.setAttributeNode(doc.createAttribute('filename'))
            e.setAttribute('filename', urdf_include)
            robot_tag.appendChild(e)
        
        xacro.process_doc(doc, mappings={'config_file_path': self.vehicle_config_path})
        
        # Parse xml to detect invalid xml before sending to gazebo
        try:
            xml_parsed = ElementTree.fromstring(doc.toxml(), parser=None)
        except ElementTree.ParseError as ex:
            self.get_logger().error(f'Invalid XML: {ex}')
            raise ex


        # Replace package:// with model:// for mesh tags if flag is set
        if self.package_to_model:
            for element in xml_parsed.iterfind('.//mesh'):
                filename_tag = element.get('filename')
                if filename_tag is None:
                    continue
                url = urlsplit(filename_tag)
                if url.scheme == 'package':
                    url = SplitResult('model', *url[1:])
                    element.set('filename', url.geturl())

        # Encode xml object back into string for service call
        res = ElementTree.tostring(xml_parsed, encoding='unicode') # type: ignore
        return str(res)

    def amend_urdf_and_spawn(self, msg: std_msgs.msg.String):
        self.final_entity_xml = self.amend_urdf(msg.data)
        self._spawn_entity()

    def reset_simulation(self, req: std_srvs.srv.Empty.Request, resp: std_srvs.srv.Empty.Response):
        self.get_logger().info('Calling service /reset_simulation')
        self.gazebo_reset_client.call_async(req)
        self._spawn_entity()
        return resp


def quaternion_from_euler(roll, pitch, yaw):
    cy = math.cos(yaw * 0.5)
    sy = math.sin(yaw * 0.5)
    cp = math.cos(pitch * 0.5)
    sp = math.sin(pitch * 0.5)
    cr = math.cos(roll * 0.5)
    sr = math.sin(roll * 0.5)

    return [
        cy * cp * cr + sy * sp * sr,
        cy * cp * sr - sy * sp * cr,
        sy * cp * sr + cy * sp * cr,
        sy * cp * cr - cy * sp * sr,
    ]

def main():
    rclpy.init(args=sys.argv[1:])
    try:
        rclpy.spin(GazeboSimulationInterface())
    except KeyboardInterrupt:
        pass
    finally:
        rclpy.shutdown()
