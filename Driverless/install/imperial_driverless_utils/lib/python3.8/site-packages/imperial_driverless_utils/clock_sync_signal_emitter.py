import time
import rclpy
import rclpy.node

import sensor_msgs.msg
import rosgraph_msgs.msg
import std_msgs.msg

class ClockSyncSignalEmitter(rclpy.node.Node):
    def __init__(self):
        super().__init__('clock_sync_signal_emitter')

        self.publisher = self.create_publisher(
            sensor_msgs.msg.LaserScan,
            'clock_sync_signal',
            1)
        
        self.clock_sub = self.create_subscription(
            rosgraph_msgs.msg.Clock,
            'clock',
            self.publish_sync_signal,
            1
        )

    def publish_sync_signal(self, msg: rosgraph_msgs.msg.Clock):
        time.sleep(0.05) # 50 ms delay doesn't affect the visualization much, 
                         # but ensures that every message is ready to be displayed
                         # and greatly reduces the CPU load due to constant polling 
        self.publisher.publish(
            sensor_msgs.msg.LaserScan(
                header=std_msgs.msg.Header(
                    stamp=msg.clock, # type: ignore
                    frame_id='base_link' # this is used to fix wheels jumping, so it makes the most
                    # sense to use the base link frame, although map or odom also work (but then weird things happen if they do not exist)
                )
            )
        )
        

def main(args=None):
    rclpy.init(args=args)

    node = ClockSyncSignalEmitter()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()
