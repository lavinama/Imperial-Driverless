import collections
import dataclasses
from typing import Protocol, TypeVar, Generic, Deque, Callable
import transforms3d  # type: ignore

import tf2_ros
import std_msgs.msg
import rclpy.time

import geometry_msgs.msg
import imperial_driverless_interfaces.msg as idi

import numpy as np

from tf2_ros.transform_listener import TFMessage


class PMsg(Protocol):
    header: std_msgs.msg.Header


T = TypeVar("T", bound=PMsg)


@dataclasses.dataclass
class TFMessageFilter(Generic[T]):
    """
    This class is a substitute for the tf2 message filter utility that's missing in python.

    The idea is as follows: store incoming stamped messages in a queue until a transform
    from their frame to the target frame becomes available, and then pass the least recent
    message to the supplied callback.

    If the queue size is to small, you might encounter a situation where the transforms never
    become available, and it will fail silently. Be aware of that.
    """

    tf_listener: tf2_ros.TransformListener
    target_frame: str
    callback: Callable[[T], None]
    queue_size: int = 10

    q: Deque[T] = dataclasses.field(init=False, default_factory=collections.deque)

    def __post_init__(self):
        self.tf_listener.buffer.registration.add(idi.ConeMap, transform_conemap)  # type: ignore
        self._original_tf_listener_sub_callback = self.tf_listener.tf_sub.callback  # type: ignore
        self.tf_listener.tf_sub.callback = self.process_then_continue

    def process_then_continue(self, data: TFMessage):
        self._original_tf_listener_sub_callback(data)  # type: ignore
        self._process()

    def insert(self, msg: T):
        if len(self.q) < self.queue_size:
            self.q.append(msg)
            self._process()
        else:
            print("message filter queue is full, dropping message")

    def _process(self):
        if not self.q:
            return

        stamp: rclpy.time.Time = rclpy.time.Time.from_msg(self.q[0].header.stamp)  # type: ignore
        try:
            transformed_msg: T = self.tf_listener.buffer.transform_full(self.q[0], self.target_frame, stamp, fixed_frame="map")  # type: ignore
            self.q.popleft()
            self.callback(transformed_msg)
        except Exception as e:
            if "Lookup would require extrapolation into the past." in str(e):
                self.q.popleft()
            elif "Lookup would require extrapolation" in str(e):
                pass
            elif "frame does not exist" in str(e):
                pass
            else:
                raise e


def transform_conemap(
    conemap: idi.ConeMap, transform_stamped: geometry_msgs.msg.TransformStamped
) -> idi.ConeMap:
    T = transform_stamped.transform  # type: ignore

    translation = [T.translation.x, T.translation.y, T.translation.z]  # type: ignore
    rotation_matrix: np.ndarray = transforms3d.quaternions.quat2mat(  # type: ignore
        [
            T.rotation.w,  # type: ignore
            T.rotation.x,  # type: ignore
            T.rotation.y,  # type: ignore
            T.rotation.z,  # type: ignore
        ]
    )

    def transform_cone(c: idi.Cone) -> idi.Cone:
        x, y, z = (
            np.matmul([c.position.x, c.position.y, c.position.z], rotation_matrix.T)
            + translation
        )
        return idi.Cone(position=geometry_msgs.msg.Point(x=x, y=y, z=z))

    conemap.left_cones = [transform_cone(c) for c in conemap.left_cones]
    conemap.right_cones = [transform_cone(c) for c in conemap.right_cones]
    conemap.big_orange_cones = [transform_cone(c) for c in conemap.big_orange_cones]
    conemap.small_orange_cones = [transform_cone(c) for c in conemap.small_orange_cones]
    conemap.header.frame_id = transform_stamped.header.frame_id  # type: ignore
    return conemap
