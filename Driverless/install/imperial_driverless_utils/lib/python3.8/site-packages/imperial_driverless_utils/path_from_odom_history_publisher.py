import sys
import time
from typing import Deque, List
import rclpy
import rclpy.node
import rclpy.duration
import rclpy.time

import nav_msgs.msg
import geometry_msgs.msg

import collections


class PathFromOdomHistoryPublisher(rclpy.node.Node):
    def __init__(self):
        super().__init__("path_from_odom_history_publisher")
        self.declare_parameter("history_length_seconds", 20).value
        self.gt_poses: Deque[geometry_msgs.msg.PoseStamped] = collections.deque()

        self.gt_publisher = self.create_publisher(nav_msgs.msg.Path, "gt_odom_path", 1)

        self.gt_clock_sub = self.create_subscription(
            nav_msgs.msg.Odometry, "ground_truth/odom", self.publish_gt_odom_path, 1
        )

        self.loc_poses: Deque[geometry_msgs.msg.PoseStamped] = collections.deque()

        self.loc_publisher = self.create_publisher(nav_msgs.msg.Path, "loc_odom_path", 1)

        self.loc_clock_sub = self.create_subscription(
            nav_msgs.msg.Odometry, "odometry/filtered", self.publish_loc_odom_path, 1
        )

    def publish_gt_odom_path(self, msg: nav_msgs.msg.Odometry):
        time.sleep(0.05)  # 50 ms delay doesn't affect the visualization much,
        # but ensures that every message is ready to be displayed
        # and greatly reduces the CPU load due to constant polling
        history_length_seconds = self.get_parameter("history_length_seconds").value
        while self.gt_poses and self.get_clock().now() - rclpy.time.Time.from_msg(
            self.gt_poses[0].header.stamp
        ) > rclpy.duration.Duration(seconds=history_length_seconds):
            self.gt_poses.popleft()
        self.gt_poses.append(
            geometry_msgs.msg.PoseStamped(header=msg.header, pose=msg.pose.pose)
        )
        self.gt_publisher.publish(
            nav_msgs.msg.Path(header=msg.header, poses=list(self.gt_poses))
        )

    def publish_loc_odom_path(self, msg: nav_msgs.msg.Odometry):
        time.sleep(0.05)  # 50 ms delay doesn't affect the visualization much,
        # but ensures that every message is ready to be displayed
        # and greatly reduces the CPU load due to constant polling
        history_length_seconds = self.get_parameter("history_length_seconds").value
        while self.loc_poses and self.get_clock().now() - rclpy.time.Time.from_msg(
            self.loc_poses[0].header.stamp
        ) > rclpy.duration.Duration(seconds=history_length_seconds):
            self.loc_poses.popleft()
        self.loc_poses.append(
            geometry_msgs.msg.PoseStamped(header=msg.header, pose=msg.pose.pose)
        )
        self.loc_publisher.publish(
            nav_msgs.msg.Path(header=msg.header, poses=list(self.loc_poses))
        )


def main(args: List[str] = sys.argv[1:]):
    rclpy.init(args=args)

    node = PathFromOdomHistoryPublisher()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    except RuntimeError as e: 
        if not "make_tuple(): unable to convert arguments to Python object" in str(e):
            raise e
    finally:
        node.destroy_node()
        rclpy.shutdown()
